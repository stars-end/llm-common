from typing import Any

from pydantic import BaseModel, ConfigDict, Field, field_validator


class SubTask(BaseModel):
    """A specific data gathering step within a larger task."""

    id: int
    description: str = Field(..., description="Specific description of data to gather")


class PlannedTask(BaseModel):
    """A high-level task that contains subtasks."""

    id: int
    description: str = Field(..., description="High level description of the task")
    sub_tasks: list[SubTask] = Field(
        default_factory=list, description="List of specific data gathering subtasks"
    )


class ExecutionPlan(BaseModel):
    """The complete execution plan generated by the planner."""

    tasks: list[PlannedTask]


class ToolCall(BaseModel):
    """A request to call a specific tool."""

    tool: str = Field(..., description="Name of the tool to call")
    args: dict[str, Any] = Field(..., description="Arguments for the tool")
    reasoning: str = Field(..., description="Why this tool is being called")


class SubTaskResult(BaseModel):
    """Result of a subtask execution."""

    task_id: int
    sub_task_id: int
    success: bool
    result: Any = None
    error: str | None = None


class AgentStory(BaseModel):
    """User story for smoke tests."""

    model_config = ConfigDict(extra="allow")

    id: str
    persona: str
    description: str | None = None
    start_url: str | None = None
    timeout_seconds: int | None = None
    goals: list[str] = Field(default_factory=list)
    steps: list[dict[str, Any]]
    metadata: dict[str, Any] = Field(default_factory=dict)

    @field_validator("steps", mode="before")
    @classmethod
    def _normalize_steps(cls, value: Any) -> list[dict[str, Any]]:
        """Normalize steps into the canonical dict-based format.

        Supports both:
        - Structured steps: list[dict] with keys like id/description/validation_criteria
        - Shorthand steps: list[str] where each string is treated as the step description
        """
        if value is None:
            return []

        if not isinstance(value, list):
            raise TypeError("steps must be a list")

        normalized: list[dict[str, Any]] = []
        for index, item in enumerate(value, start=1):
            if isinstance(item, str):
                normalized.append(
                    {
                        "id": f"step-{index}",
                        "description": item,
                        "validation_criteria": [],
                    }
                )
                continue

            if isinstance(item, dict):
                step_id = item.get("id") or f"step-{index}"
                description = item.get("description") or item.get("step") or ""
                validation_criteria = item.get("validation_criteria") or item.get("verify") or []
                if validation_criteria is None:
                    validation_criteria = []
                normalized.append(
                    {
                        **item,
                        "id": step_id,
                        "description": description,
                        "validation_criteria": validation_criteria,
                    }
                )
                continue

            raise TypeError("each step must be a dict or a string")

        return normalized


class AgentError(BaseModel):
    """Error encountered during smoke test."""

    type: str
    severity: str  # blocker, high, medium, low
    message: str
    details: dict[str, Any] = Field(default_factory=dict)
    url: str | None = None


class StepResult(BaseModel):
    """Result of a single story step."""

    step_id: str
    status: str  # pass, fail
    actions_taken: list[dict[str, Any]] = Field(default_factory=list)
    errors: list[AgentError] = Field(default_factory=list)
    duration_ms: int = 0


class StoryResult(BaseModel):
    """Result of a complete story execution."""

    story_id: str
    status: str  # pass, fail
    step_results: list[StepResult] = Field(default_factory=list)
    errors: list[AgentError] = Field(default_factory=list)


class RelevantTurns(BaseModel):
    """A list of relevant conversation turns."""

    relevant_turns: list[int] = Field(
        ..., description="List of numbers corresponding to relevant turns."
    )


class SmokeRunReport(BaseModel):
    """Overall report for a smoke test run."""

    run_id: str
    environment: str
    base_url: str
    story_results: list[StoryResult]
    total_errors: dict[str, int]
    started_at: str
    completed_at: str
    metadata: dict[str, Any] = Field(default_factory=dict)

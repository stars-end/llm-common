from typing import Any

from pydantic import BaseModel, Field, field_validator


def _normalize_step(step: str | dict[str, Any], index: int) -> dict[str, Any]:
    """Normalize a step to dict format.

    Args:
        step: Either a string description or a dict with step details
        index: Step index for generating default id

    Returns:
        Normalized dict with id, description, and optional validation_criteria
    """
    if isinstance(step, str):
        return {
            "id": f"step-{index + 1}",
            "description": step,
            "validation_criteria": [],
        }
    elif isinstance(step, dict):
        # Ensure required fields exist
        if "id" not in step:
            step = {**step, "id": f"step-{index + 1}"}
        if "validation_criteria" not in step:
            step = {**step, "validation_criteria": []}
        return step
    else:
        raise ValueError(f"Step must be string or dict, got {type(step)}")


class SubTask(BaseModel):
    """A specific data gathering step within a larger task."""

    id: int
    description: str = Field(..., description="Specific description of data to gather")


class PlannedTask(BaseModel):
    """A high-level task that contains subtasks."""

    id: int
    description: str = Field(..., description="High level description of the task")
    sub_tasks: list[SubTask] = Field(
        default_factory=list, description="List of specific data gathering subtasks"
    )


class ExecutionPlan(BaseModel):
    """The complete execution plan generated by the planner."""

    tasks: list[PlannedTask]


class ToolCall(BaseModel):
    """A request to call a specific tool."""

    tool: str = Field(..., description="Name of the tool to call")
    args: dict[str, Any] = Field(..., description="Arguments for the tool")
    reasoning: str = Field(..., description="Why this tool is being called")


class SubTaskResult(BaseModel):
    """Result of a subtask execution."""

    task_id: int
    sub_task_id: int
    success: bool
    result: Any = None
    error: str | None = None


class AgentStory(BaseModel):
    """User story for smoke tests.

    Steps can be provided as either:
    - String: "Navigate to Advisor page"
    - Dict: {"id": "step-1", "description": "Navigate to Advisor page", "validation_criteria": ["Advisor"]}

    String steps will be automatically normalized to dict format.
    """

    id: str
    persona: str
    steps: list[
        str | dict[str, Any]
    ]  # Expected keys: id, description, validation_criteria (Optional[List[str]])
    metadata: dict[str, Any] = Field(default_factory=dict)

    @field_validator("steps", mode="before")
    @classmethod
    def normalize_steps(cls, v: Any) -> list[dict[str, Any]]:
        """Normalize steps to dict format.

        Accepts both string and dict steps, converting all to dict format.
        """
        if not isinstance(v, list):
            raise ValueError("steps must be a list")

        return [_normalize_step(step, i) for i, step in enumerate(v)]

    @property
    def normalized_steps(self) -> list[dict[str, Any]]:
        """Return steps as normalized dicts.

        This property is for backward compatibility - after validation,
        steps are already normalized by the validator.
        """
        return self.steps  # type: ignore[return-value]


class AgentError(BaseModel):
    """Error encountered during smoke test."""

    type: str
    severity: str  # blocker, high, medium, low
    message: str
    details: dict[str, Any] = Field(default_factory=dict)
    url: str | None = None


class StepResult(BaseModel):
    """Result of a single story step."""

    step_id: str
    status: str  # pass, fail
    actions_taken: list[dict[str, Any]] = Field(default_factory=list)
    errors: list[AgentError] = Field(default_factory=list)
    duration_ms: int = 0


class StoryResult(BaseModel):
    """Result of a complete story execution."""

    story_id: str
    status: str  # pass, fail
    step_results: list[StepResult] = Field(default_factory=list)
    errors: list[AgentError] = Field(default_factory=list)


class RelevantTurns(BaseModel):
    """A list of relevant conversation turns."""

    relevant_turns: list[int] = Field(
        ..., description="List of numbers corresponding to relevant turns."
    )


class SmokeRunReport(BaseModel):
    """Overall report for a smoke test run."""

    run_id: str
    environment: str
    base_url: str
    story_results: list[StoryResult]
    total_errors: dict[str, int]
    started_at: str
    completed_at: str
    metadata: dict[str, Any] = Field(default_factory=dict)

    def to_json_dict(self) -> dict[str, Any]:
        """Convert to a JSON-serializable dict.

        This ensures all nested Pydantic models are properly converted
        for use with json.dump().

        Returns:
            JSON-serializable dictionary
        """
        return self.model_dump(mode="json")
